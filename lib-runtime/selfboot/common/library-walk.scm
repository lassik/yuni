(define (%selfboot-gen-loadorder libread libcheck initial-dep)
  ;; => (path libname ...)
  ;; (libread LIBNAME) => sexp
  ;; (libcheck LIBNAME) => LIBNAME(can be aliased) / #f(ignore)
  (define order '())
  (define (libnamestrip libname)
    (if (pair? libname)
      (let ((sy (car libname)))
       (case sy
         ((rename except only for)
          (libnamestrip (cadr libname)))
         (else libname)))
      libname))
  (define (libname=? a b)
    (cond
      ((and (null? a) (null? b)) #t)
      (else
        (and (pair? a)
             (pair? b)
             (let ((aa (car a))
                   (bb (car b)))
               (and (eqv? aa bb)
                    (libname=? (cdr a) (cdr b))))))))
  (define (libname=?/list lis nam)
    (and (pair? lis)
         (let ((a (car lis)))
          (or (libname=? a nam)
              (libname=?/list (cdr lis) nam)))))
  (define (is-loaded? lib)
    (let loop ((q order))
     (and (pair? q)
          (let ((n (caar q))
                (next (cdr q)))
            (or (libname=?/list n lib)
                (loop next))))))
  (define (tryload! lib)
    (let* ((usagename (libnamestrip lib))
           (truename (libcheck usagename)))
     (when (and truename (not (is-loaded? truename)))
       (let* ((code (libread truename))
              (deps (%selfboot-library-depends code))
              (syms (%selfboot-library-exports code))
              (names (if (not (libname=? truename usagename))
                       (list truename usagename)
                       (list usagename))))
         (for-each tryload! deps)
         (set! order (cons (cons names (cons deps syms)) order))))))

  (for-each tryload! (map libnamestrip initial-dep))
  (set! order (reverse order))
  ;;(for-each (lambda (b) (write b) (newline)) order)
  order)
